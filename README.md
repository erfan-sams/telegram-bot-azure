# Telegram LLM Bot with OpenRouter & Azure Serverless

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A sophisticated, serverless Telegram bot that leverages Large Language Models (LLMs) via the OpenRouter API, maintains conversational history using Azure Cosmos DB, and is securely hosted on Azure Functions with Azure Key Vault for secret management.

<!-- Optional: Add a GIF or screenshot of your bot in action here! -->
<!-- ![Bot Demo](./docs/demo.gif) -->

## Table of Contents

- [Features](#features)
- [Tech Stack](#tech-stack)
- [Project Structure](#project-structure)
- [Prerequisites](#prerequisites)
- [Azure Resource Provisioning (Summary)](#azure-resource-provisioning-summary)
- [Deployment to Azure Functions](#deployment-to-azure-functions)
- [Local Development & Testing](#local-development--testing)
- [Configuration](#configuration)
- [Monitoring](#monitoring)
- [Contributing](#contributing)
- [License](#license)
- [Contact](#contact)
- [Acknowledgements](#acknowledgements)

## Features

*   **Conversational AI:** Engages users with responses generated by various LLMs accessible through OpenRouter.
*   **Persistent Memory:** Remembers conversation history for each chat using Azure Cosmos DB.
    *   Stores full conversation history.
    *   Sends a truncated (e.g., last 10 turns/20 messages) history to the LLM for context.
*   **Customizable Persona:** System prompt allows for defining the bot's personality and behavior.
*   **Serverless & Scalable:** Hosted on Azure Functions (Consumption Plan), ensuring cost-effectiveness and automatic scaling.
*   **Secure Secret Management:** API keys and sensitive configurations are securely stored in Azure Key Vault.
*   **Asynchronous Operations:** Built with `asyncio` and asynchronous libraries for efficient handling of I/O.
*   **"Typing..." Indicator:** Provides user feedback during LLM processing.
*   **Basic Commands:** Includes `/start` (initiates/resets conversation) and `/clear` (clears conversation history).
*   **Message Length Control:** Limits user input length to prevent overly long prompts.
*   **Detailed Logging:** Configured for effective monitoring and debugging in Azure Application Insights.

## Tech Stack

*   **Language:** Python 3.11+
*   **Telegram Interaction:** `python-telegram-bot`
*   **LLM Gateway:** OpenRouter.ai (using the `openai` Python library)
*   **Database:** Azure Cosmos DB (NoSQL, Core SQL API, asynchronous client `azure.cosmos.aio`)
*   **Hosting:** Azure Functions (Python runtime, Consumption Plan, HTTP Trigger)
*   **Secret Management:** Azure Key Vault
*   **Identity:** Azure Managed Identity (for Function App to access Key Vault)
*   **Development & Deployment:** Azure CLI, Azure Functions Core Tools

## Project Structure

```
telegram_llm_bot/
├── TelegramWebhookHandler/     # Azure Function main code
│   ├── __init__.py             # Function logic, PTB setup, handlers
│   └── function.json           # Azure Function binding configuration
├── requirements.txt            # Python dependencies
├── host.json                   # Azure Functions host configuration
├── local.settings.json         # Example for local Functions settings (gitignored)
├── .env                        # Example for local bot.py execution (gitignored)
├── .gitignore                  # Specifies intentionally untracked files
└── README.md                   # This file
```

## Prerequisites

*   Python 3.11 or higher (ensure your Azure Function runtime matches)
*   An Azure Subscription (Student or Pay-As-You-Go)
*   Azure CLI installed and configured (`az login` and set default subscription)
*   Azure Functions Core Tools installed
*   A Telegram Bot Token (from @BotFather on Telegram)
*   An OpenRouter API Key (from [OpenRouter.ai](https://openrouter.ai/))
*   Git installed

## Azure Resource Provisioning (Summary)

Before deploying to Azure Functions, you must have the following Azure resources created. It's recommended to place them in the same Resource Group and Azure Region for optimal performance and management.

1.  **Azure Resource Group:**
    *   Example Name: `MyTelegramBotRG`
    *   Example Region: `westeurope` (Choose your preferred region)
2.  **Azure Cosmos DB Account:**
    *   API: Core (SQL)
    *   Capacity Mode: Provisioned throughput (Select the **Free Tier Discount** if available for your subscription)
    *   Database within the account (e.g., `TelegramBotDB`)
    *   Container within the database (e.g., `ChatHistories`) with partition key path set to `/chat_id`
3.  **Azure Key Vault:**
    *   Example Name: `mytelegrambot-kv`
    *   Permission Model: **Azure role-based access control (RBAC)** is recommended.
    *   Secrets Stored:
        *   `TELEGRAM-BOT-TOKEN`
        *   `OPENROUTER-API-KEY`
        *   `COSMOS-DB-URI`
        *   `COSMOS-DB-KEY`
        *   (Optional) `OPENROUTER-BASE-URL` (if not using the default in code)

*(Refer to separate Azure CLI scripts or detailed setup guides if you need to provision these from scratch. The deployment steps below assume these exist.)*

## Deployment to Azure Functions

This guide uses Azure CLI. Replace example values with your specific names and chosen region.

**1. Define Variables (Optional, for scriptability - review and use your actual values):**
```bash
# Variables for Azure resources - REPLACE THESE WITH YOUR CHOSEN VALUES
RESOURCE_GROUP="MyTelegramBotRG"
LOCATION="westeurope" # Use the same region as your Resource Group
AZURE_SUBSCRIPTION_ID="<Your-Azure-Subscription-ID>" # Optional if default is set correctly

# These names need to be GLOBALLY UNIQUE
STORAGE_ACCOUNT_NAME="mytelegrambotstoragefn" # e.g., yourinitialsbotstoragefn (lowercase, numbers, 3-24 chars)
FUNCTION_APP_NAME="mytelegrambot-fn"       # e.g., yourinitialsbottelegramfn
KEY_VAULT_NAME="mytelegrambot-kv"          # Your existing Key Vault name from provisioning summary

PYTHON_RUNTIME_VERSION="3.11" # Ensure this matches your project and Azure Functions support
```

**2. Create Azure Storage Account (Required by Function App):**
*(Skip if you already have one dedicated for this Function App)*
```bash
az storage account create  
  --name "$STORAGE_ACCOUNT_NAME"  
  --resource-group "$RESOURCE_GROUP"  
  --location "$LOCATION"  
  --sku "Standard_LRS"  
  --kind "StorageV2"  
  --subscription "$AZURE_SUBSCRIPTION_ID"
```

**3. Create Azure Function App:**
```bash
az functionapp create  
  --name "$FUNCTION_APP_NAME"  
  --resource-group "$RESOURCE_GROUP"  
  --storage-account "$STORAGE_ACCOUNT_NAME"  
  --consumption-plan-location "$LOCATION"  
  --runtime python  
  --runtime-version "$PYTHON_RUNTIME_VERSION"  
  --functions-version 4  
  --os-type Linux  
  --subscription "$AZURE_SUBSCRIPTION_ID"
```

**4. Enable System-Assigned Managed Identity for Function App:**
```bash
az functionapp identity assign  
  --name "$FUNCTION_APP_NAME"  
  --resource-group "$RESOURCE_GROUP"  
  --subscription "$AZURE_SUBSCRIPTION_ID"
```
Execute the following to get the `principalId` and save it:
```bash
FUNCTION_APP_PRINCIPAL_ID=$(az functionapp identity show --name "$FUNCTION_APP_NAME" --resource-group "$RESOURCE_GROUP" --subscription "$AZURE_SUBSCRIPTION_ID" --query "principalId" --output tsv)
echo "Function App Principal ID: $FUNCTION_APP_PRINCIPAL_ID" # Copy this ID
```

**5. Grant Function App Access to Key Vault:**
Assign the "Key Vault Secrets User" role to your Function App's Managed Identity on your Key Vault.
```bash
# Ensure FUNCTION_APP_PRINCIPAL_ID is set from the previous step
# Ensure KEY_VAULT_NAME is set to your actual Key Vault name
KEY_VAULT_ID=$(az keyvault show --name "$KEY_VAULT_NAME" --resource-group "$RESOURCE_GROUP" --subscription "$AZURE_SUBSCRIPTION_ID" --query id --output tsv)

az role assignment create  
  --role "Key Vault Secrets User"  
  --assignee-object-id "$FUNCTION_APP_PRINCIPAL_ID"  
  --assignee-principal-type ServicePrincipal  
  --scope "$KEY_VAULT_ID"  
  --subscription "$AZURE_SUBSCRIPTION_ID"
```
*(Allow a minute or two for permissions to propagate.)*

**6. Configure Function App Application Settings (Referencing Key Vault):**
```bash
# Ensure KEY_VAULT_NAME is set to your actual Key Vault name
KEY_VAULT_URI_VALUE="https://$KEY_VAULT_NAME.vault.azure.net/"

az functionapp config appsettings set  
  --name "$FUNCTION_APP_NAME"  
  --resource-group "$RESOURCE_GROUP"  
  --subscription "$AZURE_SUBSCRIPTION_ID"  
  --settings  
    KEY_VAULT_URI="$KEY_VAULT_URI_VALUE"  
    TELEGRAM_BOT_TOKEN="@Microsoft.KeyVault(SecretUri=${KEY_VAULT_URI_VALUE}secrets/TELEGRAM-BOT-TOKEN/)"  
    OPENROUTER_API_KEY="@Microsoft.KeyVault(SecretUri=${KEY_VAULT_URI_VALUE}secrets/OPENROUTER-API-KEY/)"  
    COSMOS_DB_URI="@Microsoft.KeyVault(SecretUri=${KEY_VAULT_URI_VALUE}secrets/COSMOS-DB-URI/)"  
    COSMOS_DB_KEY="@Microsoft.KeyVault(SecretUri=${KEY_VAULT_URI_VALUE}secrets/COSMOS-DB-KEY/)"  
    OPENROUTER_BASE_URL="https://openrouter.ai/api/v1"  
    FUNCTIONS_WORKER_RUNTIME="python"
```
*Note: Secret names in Key Vault (`TELEGRAM-BOT-TOKEN`, etc.) must exactly match those in the SecretUris.*

**7. Prepare for Deployment:**
   * Make sure you have `requirements.txt`, `host.json`, and your function code in the `TelegramWebhookHandler` folder (`__init__.py`, `function.json`) as described in "Project Structure".
   * Create `local.settings.json.example` and `.env` files in your repository (these should be gitignored in their actual `local.settings.json` and `.env` forms).

**8. Deploy the Code:**
   Navigate to your project's root directory in your terminal.
   ```bash
   # Ensure you are logged into Azure CLI and the correct subscription is set
   func azure functionapp publish "$FUNCTION_APP_NAME" --python
   ```

**9. Set Telegram Webhook:**
   Get your deployed Azure Function URL:
   1. Go to Azure Portal -> Function Apps -> `$FUNCTION_APP_NAME`.
   2. Under "Functions", click `TelegramWebhookHandler`.
   3. Click "Get Function Url" and copy it.
   Set the webhook (replace `<YOUR_TELEGRAM_BOT_TOKEN>` and `<YOUR_AZURE_FUNCTION_URL>`):
   ```
   https://api.telegram.org/bot<YOUR_TELEGRAM_BOT_TOKEN>/setWebhook?url=<YOUR_AZURE_FUNCTION_URL>
   ```
   (You can paste this into a browser or use `curl`). Remember to stop any local polling scripts.

## Local Development & Testing

1.  **Clone Repository & Create Virtual Environment:**
    ```bash
    git clone https://github.com/<Your-GitHub-Username>/<Your-Repo-Name>.git # Replace with your repo URL
    cd <Your-Repo-Name>
    python -m venv .venv
    source .venv/bin/activate  # Linux/macOS
    # .venv Scripts activate    # Windows
    ```
2.  **Install Dependencies:**
    ```bash
    pip install -r requirements.txt
    ```
3.  **Configure for Local Execution:**
    *   **For `bot.py` (direct polling, if you have a separate script for this - optional):**
        Create a `.env` file in the project root (add to `.gitignore`). See `.env` for structure.
        Populate with your actual secrets.
    *   **For Azure Functions Local Runtime (`func host start`):**
        Create/populate `local.settings.json` (add to `.gitignore`). See `local.settings.json.example`.
        It needs `KEY_VAULT_URI` (e.g., `https://mytelegrambot-kv.vault.azure.net/`) if you want it to load other secrets from Key Vault (requires Azure CLI login: `az login`). Otherwise, you can put all secret values directly into `local.settings.json` for fully local testing.
        Example `local.settings.json`:
        ```json
        {
          "IsEncrypted": false,
          "Values": {
            "AzureWebJobsStorage": "UseDevelopmentStorage=true",
            "FUNCTIONS_WORKER_RUNTIME": "python",
            "KEY_VAULT_URI": "https://mytelegrambot-kv.vault.azure.net/",
            "TELEGRAM_BOT_TOKEN": "YOUR_LOCAL_TOKEN",
            "OPENROUTER_API_KEY": "YOUR_LOCAL_KEY",
            "COSMOS_DB_URI": "YOUR_LOCAL_COSMOS_URI",
            "COSMOS_DB_KEY": "YOUR_LOCAL_COSMOS_KEY"
          }
        }
        ```
4.  **Running Azure Function Locally:**
    *   Ensure Azure Functions Core Tools are installed.
    *   Run from project root: `func host start`
    *   For webhook testing, use a tool like `ngrok` to expose your local function endpoint (usually `http://localhost:7071/api/TelegramWebhookHandler`) to Telegram.

## Configuration

*   **Azure Key Vault:** Primary store for all sensitive API keys (`TELEGRAM-BOT-TOKEN`, `OPENROUTER-API-KEY`) and connection strings (`COSMOS-DB-URI`, `COSMOS-DB-KEY`).
*   **Function App Application Settings:** References secrets in Key Vault. Provides `KEY_VAULT_URI` and other non-sensitive settings like `OPENROUTER_BASE_URL`.
*   **`TelegramWebhookHandler/__init__.py`:** Contains constants like `SYSTEM_MESSAGE_CONTENT`, `MAX_CONVERSATION_MESSAGES`, `MAX_USER_MESSAGE_LENGTH`, and the default LLM model choice.

## Monitoring

*   **Azure Portal:**
    *   **Function App -> Monitor -> Invocations:** For invocation history and status.
    *   **Function App -> (Specific Function) -> Developer -> Log stream:** For live logs.
    *   **Application Insights:** (Linked to Function App) For detailed telemetry, exceptions, traces, and performance.
*   **OpenRouter Dashboard:** For monitoring LLM API usage and costs.

## Contributing

Contributions are welcome! Please open an Issue to discuss an idea or submit a Pull Request.
1. Fork the Project
2. Create your Feature Branch (`git checkout -b feature/MyAmazingFeature`)
3. Commit your Changes (`git commit -m 'Add MyAmazingFeature'`)
4. Push to the Branch (`git push origin feature/MyAmazingFeature`)
5. Open a Pull Request

## License

Distributed under the MIT License. Create a `LICENSE` file in your repository root and add the MIT License text.
(You can find MIT License text here: [https://opensource.org/licenses/MIT](https://opensource.org/licenses/MIT))
